#!/usr/bin/env python3

import glob, sys, os

pwd = os.getcwd()
pwd_split = pwd.split('/')
print(pwd_split)
project = pwd_split[pwd_split.index('bvmt') + 1]

def is_test_file(f):
    return f.endswith('test.h')

def make_test_name(f):
    if f.startswith('..'):
        partial = f[3:-2].replace('/', '__')
    else:
        partial = f[:-2].replace('/', '__')
    return partial.replace('-', '_')

def get_relative_path(f):
    f_split = f.split('/')
    after_project_index = f_split.index(project) + 1
    return '/'.join(f_split[after_project_index:])

with open('test.h', 'w') as writable:
    files = list(map(get_relative_path, sys.argv[1:]))
    files.sort()
    print('adding ' + ' '.join(files) + ' to tests')
    assert len(files) > 0, "expected some files in args: " + "".join(sys.argv)

    writable.write('// AUTOGENERATED BY %s\n'%sys.argv[0])
    writable.write('#ifndef __TEST_H__\n')
    writable.write('#define __TEST_H__\n')
    for f in files:
        if is_test_file(f):
            continue
        writable.write('#include "%s"\n'%f)

    for f in files:
        if is_test_file(f):
            continue
        writable.write('namespace bvmt {\n')
        writable.write('void test__%s();\n'%make_test_name(f))
        writable.write('}\n') # end namespace
    writable.write('#ifndef NDEBUG\n')
    writable.write('void run_tests()\n{')
    writable.write('\tstd::cout << "Running tests...\\n";\n')
    writable.write('\tbvmt::capturer TestErrorOutput(std::cerr);\n')
    writable.write('\ttry\n\t{')
    tabs = '\t'
    for f in files:
        if is_test_file(f):
            continue
        writable.write('%sTRY("testing %s.cc/h", bvmt::test__%s());\n'%(tabs, f[:-2], make_test_name(f)))
        tabs = '\t\t'
    writable.write('\t}\n\tcatch (const bvmt::error& E)\n\t{')
    writable.write('\tTestErrorOutput.stopCapture();\n\t')
    writable.write('\tstd::cerr << TestErrorOutput.pull();\n\t')
    writable.write('\tstd::cerr << RED_TEXT_OUTPUT "Error! " << E.Message << "\\n";\n\t')
    writable.write('\tstd::cerr << " at " << E.At << NORMAL_TEXT_OUTPUT "\\n";\n\t')
    writable.write('\tthrow;\n')
    writable.write('\t}\n')
    writable.write('\tstd::cout << "Finished tests, everything looks good!\\n";\n')
    writable.write('}\n')

    writable.write('#endif\n')
    writable.write('#endif\n')
